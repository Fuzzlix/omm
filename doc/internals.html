<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>One More Maketool, a lua based extensible build engine.</title>
	<meta name="author" content="Ulrich Schmidt"/>
	<meta name="date" content="2016/05/25"/>
	<meta name="comment" content="No Comment yet."/>
	<link type="text/css" rel="stylesheet" href="omm.css"/>
</head>
<body>

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;"><img src="fuzzlix.gif" alt="" /></th>
	<th style="text-align:center;"><a href="readme.html">readme</a></th>
	<th style="text-align:center;"><a href="makefiles.html">makefiles</a></th>
	<th style="text-align:center;"><a href="todo.html">todo</a></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
</tr>
</tbody>
</table>

<h1 id="omminternals">OMM Internals</h1>

<hr />

<h2 id="namingconventions">Naming conventions</h2>

<ul>
<li>Commands like <code>cc</code>, <code>c99</code>, <code>cpp</code>, <code>file</code>, &#8230; are called <em>tools</em>.</li>
<li><em>Tools</em> may have <em>actions</em> like <code>.program</code>, <code>.library</code>. or <code>.group</code>.<br/>
 <em>Actions</em> may have any name valid as a lua field name but
 not already existing <code>clTools</code> field names.</li>
<li><em>Tools</em> are defined and managed inside <em>toolchains</em>.</li>
<li><em>Toolchains</em> can be <em>loaded</em> and/or <em>activated</em>.</li>
<li><em>Loading</em> a <em>toolchain</em> means, requiring the toolchain module
 and registering the <em>toolchain</em> and ther <em>actions</em> inside the
 <em>toolchain manager</em>.</li>
<li><em>Activating</em> a toolchain means, inserting all actions of
 a <em>loaded</em> toolchain into the makefile sandbox environment.
 (Most times this happens automatically when a makescript
 try to use a tool the 1st time.)</li>
</ul>

<h2 id="luavariablenames">Lua variable names</h2>

<ul>
<li>class names start with <code>cl</code> followed by a capital letter.
 eg. <code>clToolchain</code>, <code>clMakefile</code>, &#8230;</li>
<li>object names start with a capital letter.
 eg. <code>Tools</code>, <code>Makefile</code>, &#8230;</li>
<li>fixed values (constants) are all capitalized.
 eg. <code>TOOLCHAIN_PREFIX</code>, <code>_DEBUG</code>, &#8230;</li>
<li>predefined makefile valiables are all capitalized.
 eg. <code>CC</code>, <code>CXX</code>, <code>WINDOWS</code>, &#8230;</li>
<li>all other variables start with lower case letter.</li>
<li>all other names are <em>exceptions</em> from the convention. ^^</li>
</ul>

<hr />

<h2 id="preloadedmodules.">preloaded modules.</h2>

<p>Some modules to require are stored in the main source file as preloaded
modules for 3 reasons. 1st, for a user it is easier to copy one file but a
entire file tree. 2nd, the modules 30log and os.cmdl are modified versions of
there orginals and preloading and renaming the modified versions avoids
version conflicts. 3rd, basic toolchains are preloaded to garanty basic
functionality of the main program.</p>

<hr />

<h2 id="toolchainhandling">Toolchain handling</h2>

<p>Toolchain handling is mainly done by the <code>Tools</code> object which is a object of <code>clTools</code>.
<code>clTools:load()</code> first tries to find a external toolchain and, if not successful,
try to find a internal/preloaded toolchain. Internal toolchain names are
prefixed by <code>&quot;tc_&quot;</code> eg. the Toolchain <code>&quot;gnu&quot;</code> is preloaded in a module named <code>&quot;tc_gnu&quot;</code>.</p>

<p><strong>Example:</strong> </p>

<p>To extend the preloaded toolchain &#8220;files&#8221;, simply create a new module
<code>&quot;omm_files.lua&quot;</code> somewhere inside your <code>package.path</code>.
First require the old internal toolchain, you want to extend: </p>

<pre><code>local Files = require &quot;tc_files&quot;;
</code></pre>

<p>Require &#8220;Make&#8221;. This is the main object for supplying internal informations and
functionality. (Note the capital &#8220;M&#8221; in the module name!)</p>

<pre><code>local Make = require &quot;Make&quot;;
</code></pre>

<p>Now get the Toolchains object from Make. It provides all functionality you need
to create and register the new tools, you want to create.</p>

<pre><code>local Toolchains = Make.tools;
</code></pre>

<p>Now you are ready to write your code into the new toolchain module.
Finally return. There is nothing to return because all tool registration is hopefully
already done by <code>Toolchains</code>.</p>

<pre><code>return;
</code></pre>

<hr />

<h2 id="themakeobject">The Make object</h2>

<p>The Make object is the central hub for all needed informations.
It stores for instance:</p>

<ul>
<li>File and target lists</li>
<li>The Needs list</li>
<li>The toolchain manager</li>
<li>usefull utility functions</li>
<li>&#8230;</li>
<li>command line options</li>
</ul>

<p>It can be called to start a make-run.
It is available in makescripts as <code>make</code> and can be required
in toolchain modules with <code>require &quot;Make&quot;</code>.</p>

<hr />

<h2 id="maketreenodes">Make tree nodes</h2>

<p>The root of a make tree is a <em>Target</em> (clTarget). </p>

<ul>
<li><em>Targets</em> may have a field <em>action</em> which holds a method to execute.
(The targets &#8216;clean&#8217; and &#8216;CLEAN&#8217; are implemented this way.) Targets usually
have a field &#8216;deps&#8217;, which points to a <em>Targetlist</em>.</li>
<li><em>Targetlists</em> hold a array of <em>Files</em> and/or <em>Targets</em>.</li>
<li><em>Files</em> can be of subtype <em>SourceFile</em>, <em>Tempfile</em> or <em>Targetfile</em>.</li>
</ul>

<p><em>Sourcefiles</em> are read-only for OMM and needs to be present.<br/>
<em>Tempfiles</em> are created as nessesary.<br/>
<em>Targetfiles</em> are the goal to create for the make process. </p>

<hr />

<h2 id="needs">Needs</h2>

<p>Needs are basically named collections of action parameters:</p>

<ul>
<li>defines: aditional defines for compiler</li>
<li>incdir: include dir(s)</li>
<li>libs: libs to link</li>
<li>libdir: lib search path(s)</li>
<li>prerequisites: Targets needed to fulfill this need.<br/>
 (This field will be <em>ignored</em>, when exporting
 needs to a need file.)</li>
</ul>

<p>It is also possible to assign <em>aliases</em> to needs. This way it becomes possible
to call sub-makefiles multiple times with different parameter sets stored in
different needs.</p>

<hr />

<h2 id="themakeprocess">The make process</h2>

<p>The make process is a 3 pass run:</p>

<h3 id="pass1">Pass 1</h3>

<p><strong>All</strong> marefiles are read and the make tree becomes generated. Dependency files will be read, if present.<br/>
This pass may error out if there are: </p>

<ul>
<li>syntax errors in makefiles</li>
<li>malformed action parameters.
 (&#8220;from=&#8221; parameters are ignored in this pass.)</li>
<li>unsatisfied needs.</li>
<li>non existend source files</li>
</ul>

<p>All makescripts use the same sandbox environment and share
all global valiables. This way a earlier scanned makefile
may give informations to later scanned makefiles. There is
no need anymore, to pass values via the os environment.</p>

<h3 id="pass2">Pass 2</h3>

<p>The dirtyness of all nodes becomes calculated. Also the
&#8220;from=&#8221; parameters become expanded.</p>

<h3 id="pass3">Pass 3</h3>

<p>For all dirty treenodes the target(s) depend on: </p>

<ul>
<li>The action-functions become executed.</li>
<li>The command line becomes generated and executed. Dependency files may become generated.</li>
</ul>

<h3 id="thefromtrick">The &#8220;from&#8221; trick</h3>

<p>There are 2 reasons to implement the &#8220;from&#8221; parameter:</p>

<ul>
<li>You may define somthing only once, you want to store in the
 need and also use as a action parameter.</li>
<li>Some targets defined later in your makefile(s) may want to add some
 additional defines/libs,&#8230; to a need they depend on.</li>
</ul>

<p><strong>Example:</strong><br/>
The lua library is build by default with <code>&quot;LUA_BUILD_AS_DLL&quot;</code> only.
The later <code>&quot;my_module&quot;</code> target needs the lua lib built with <code>&quot;LUA_COMPAT_MODULE&quot;</code>.
The my_module makescript may add in the 1st pass this define to the &#8220;lua&#8221;-need.</p>

<pre><code>make.Needs&quot;lua&quot;.defines:add(&quot;LUA_COMPAT_MODULE&quot;)
</code></pre>

<p>Need fields are stored in StringList-objects. Stringlist objects store each
string value only once. This means, if <code>&quot;LUA_COMPAT_MODULE&quot;</code> is already present
in .defines, the shown line has no effect and does no harm.
If the need &#8220;lua&#8221; does not exist, the command creates a error.<br/>
In the 2nd pass the from-fields become expanded and there values
become stored/added in treenode fields.<br/>
In the 3rd pass, the lua lib becomes compiled with <code>&quot;LUA_BUILD_AS_DLL LUA_COMPAT_MODULE&quot;</code>.</p>

</body>
</html>
